clearvars
close all
%% Planning algorithm
%Sliding Motion
addpath(genpath('instantaneous_mechanism_method'));
addpath(genpath('pathmexmaci64')); % path of path solver
mp = struct();
%finger dimensions
mp.links = [.08 .05]; %m
mp.mass = [.5 .3 .05]; %kg
mp.I_rod = @(m,l) (m*l^2)/12;
mp.I = [mp.I_rod(mp.mass(1),mp.links(1)) mp.I_rod(mp.mass(2),mp.links(2))]; %moment of inertias kg m^2
%object dimensions
mp.dim = [.03 .05]; %m [height length]
mp.dt = .01;
mp.mu = [.1 .9]; %friction coefficents [object/floor , finger/object]
%gravity parameters
mp.g_acc = 9.80665;
mp.g_dir = 3*pi/2;
mp.g_force = [mp.g_acc*cos(mp.g_dir) mp.g_acc*sin(mp.g_dir)]; %Fg_x Fg_y
%motion primitive
mp.time = [.5 .5 .5]; %s time for each step
mp.pos = [.05 .1 .05 .1]; %m x coordinate [inital, ..., final]
mp.p_con = [0 ; mp.dim(1)]; %contact point x y
%generate sliding motion plan
mp = sliding_motion(mp);
svaj_plot(mp);
%lp dynamics
mp.x=cell(1,length(mp.svaj_curve));
mp.fval=1:length(mp.svaj_curve);
mp = lp_dynamics_sliding(mp);
mp.lp = cell2mat(mp.x);
mp = torque_plot_s(mp);
%mp.filename ='sliding.gif';
%mp.gif_fps=10;
%sliding_plot(mp);

% gathering torques 
T1 = mp.lp(8,:);
T2 = mp.lp(9,:);

%% simulation validation
%%input: 1)angular impulse on each joint, 2) applied impulse on box
global tau_1 tau_2 p_x p_y p_z ;

% 2R manipulator
tau_1 = T1(1); % joint 1 (N.s)
tau_2 = T2(1); % joint 2 (N.s)
% box
p_x = 0; % applied impulse along x axis
p_y = 0; % applied impulse along y axis
p_z = 0; % angular impulse about z axis

%%globalize variables

global h;
h = mp.dt; % time-step length (second)

% N - the number of iteration
N= 150; 

%%defining the global variables

global I_z1 I_z2 m1 m2 L1 L2 r1 r2 m I_z L H g muRB  muBG eRB_t eBG_t ;

m1 = mp.mass(1); % mass of bar 1 of 2R manipulator
m2 = mp.mass(2); % mass of bar 2 

L1 = mp.links(1); % length of bar 1 (meter)
L2 = mp.links(2);  % length of bar 2 (meter)
r1 = L1/2; % relative position of c.m on bar 1
r2 = L2/2; % relative position of c.m on bar 2

I_z1 = mp.I(1); % moment of inertia of bar 1
I_z2 = mp.I(2); % moment of inertia of bar 2

m = mp.mass(3); % mass of the box
I_z = 1; % moment of inertia about z axis
H = mp.dim(1); % height of the box
L = mp.dim(2); % length of the box
g = mp.g_acc; % acceleration due to gravity (m/s^2)
muRB = mp.mu(2); % coefficient of friction between the tip and box
muBG = mp.mu(1); % coefficient of friction between the box and ground
eRB_t = 1; 
eBG_t = 1;

%%determine the initial configuration of the box and 2R manipulator 

% configuration of the box:
q_x = mp.pos(1);    % x coordinates of c.m of box
q_y = mp.dim(1)/2;   % y coordinates of c.m of box
theta = 0;   % orientation of the box

% configuration of the 2R manipulator:
% we define 1) the coordinates of the tip (a_x and a_y)
%           2) using inverse kinematics to determine theta1 and theta2

% assuming tip lies on the perimeter of the box
d = 0.5; % 0<= d <= 1 related position of tip on the top side of the box
a_x = q_x;
a_y = mp.dim(1);   
% inverse kinematics
[theta1,theta2] = inverse_2R(mp.links(1),mp.links(2),a_x,a_y);

% q_old - position and orientation vector at l, q_old=[theta_1o;theta_2o;q_xo;q_yo;theta_o]
global q_old;

q_old = [theta1;theta2;q_x;q_y;theta];

% nu_old - generalized velocity vector at l, nu_old=[w_1o;w_2o;v_xo;v_yo;w_o]
global nu_old;

nu_old = [0;0;0;0;0];
